# -*- coding: utf-8 -*-
"""DM8_apriory_on_dataset_my.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h7PVXSUTnIz8Xxr6egC1QbCNhWjkSYlE
"""

print("paractical 8")

import pandas as pd

df=pd.read_csv("/content/final.csv")
df

import ast

conference=df["conference"]

conference

conference=conference[:500]
print(conference)
tempconf=[]
for i in range(len(conference)):
  # print(conference[i])
  # print(type(conference[i]))
  temp=((ast.literal_eval(str(conference[i]))))
  # print(type(temp))
  tempconf.append(temp)

tempconf
conference=tempconf

conference
print((conference[0][0]))

auth=df["author"]
auth=auth[:500]
auth



dic={}
unique=set()
for i in conference:
  # print(i)
  for j in (i):
    unique.add(j)

print(unique)
print(len(unique))



print(conference)
print(conference[1][1])



for conf in unique:
  print(conf)
  auth_lst=[]
  for i in range(500):
    if(conf in (conference[i])):
      auth_lst.append(auth[i])

  print(auth_lst)
  dic[(conf)]=auth_lst

print(len(dic))

unique=set()
for i in dic.values():
  # print(i)
  for j in i:
    unique.add(j)
    # print(unique)

print(unique)
print(len(unique))

name2num={}
id=1
for i in unique:
  name2num[i]=id
  id=id+1

print(len(name2num))

def Merge(dict1, dict2):
  return(dict2.update(dict1))

#runnig algorithm one time
original=dic
pre={}#dictionary of list of item and support count
for i in unique:
  item_set = set()
  item_set.add(i)

  #count of i1 in whole dataset, count of i2 in whole dataset ....
  supportCnti=0
  for j in dic.values():
    supportCnti=supportCnti+j.count(i)

  # print("count of ",i," is ",supportCnti)

  # print(item_set,supportCnti)
  pre[frozenset(item_set)]=supportCnti

# Merge(all,pre)
# print(all)

for i in pre:
  for j in i:
    print(j, end=" ")
  print(pre[i])

min_support=2

def rmv(pre,min_support):
  new_pre = {}
  for key,val in pre.items():
    if(val>=min_support):
      new_pre[key] = val

  # print("here")
  return new_pre

removed=rmv(pre,min_support)

# print(removed)
for i in removed:
  for j in i:
    print(j, end=" ")
  print(removed[i])

# def have_to_take_first(frozen1,frozen2,dic):
#   first=list(frozen1)
#   second=list(frozen2)
#   print(first,second)

print(dic)
print(len(dic))
def count_combined(combined,dic):
  combined=list(frozen_combined)
  # print(dic)
  # print(combined)
  new_cnt=0
  for i in dic:
    cmplst=dic[i] #["I1","I2","I5"],["I2","I4"]
    # print(cmplst)
    # flag=True
    # for i in combined:
    #   if(i in cmplst):
    #     continue
    #   else:
    #     flag=False
    all_present = all(element in cmplst for element in combined)
    if(all_present):
      new_cnt=new_cnt+1
    # if(flag==True):
    #   new_cnt=new_cnt+1

  return new_cnt


# def rmv(pre,min_support):
#   new_pre = {}
#   for key,val in pre.items():
#     if(val>=min_support):
#       new_pre[key] = val

#   # print("here")
#   return new_pre

cur={}
i=0
for frozen1,support1 in pre.items():
  j=0
  for frozen2,support2 in pre.items():
    # print(i,j)
    # print(frozen1,support1)
    # print(frozen2,support2)
    if(j<=i):
      j=j+1
      continue
    else:
      combined = frozen1.union(frozen2)
      print(combined)
      # new_cnt=count_combined(combined,dic)
      cur[combined]=new_cnt
    j=j+1
  i=i+1

print(len(cur))
# for i in cur:
#   print(i,cur[i])

def have_to_take(frozen1,frozen2,dic):
  first=list(frozen1)
  second=list(frozen2)
  first.sort()
  second.sort()

  # print(first,second)
  if(first[:len(first)-1] != second[:len(second)-1]):
    return False

  return True

while(True):
  pre=cur
  # for i in pre:
  #   for j in i:
  #     print(j, end=" ")
  #   print(pre[i])

  print()
  print()
  # print("pre",pre)
  pre=rmv(pre,min_support)
  # print("pre",pre)
  # for i in pre:
  #   for j in i:
  #     print(j, end=" ")
  #   print(pre[i])
  # print()
  cur={}

  # break

  i=0
  for frozen1,support1 in pre.items():
    j=0
    for frozen2,support2 in pre.items():
      if(j<=i):
        j=j+1
        continue
      elif(have_to_take(frozen1,frozen2,original)):
        combined = frozen1.union(frozen2)
        new_cnt=count_combined(combined,dic)
        cur[combined]=new_cnt
        # print("have to take ",frozen1,frozen2)
        # break
      j=j+1
      # break
    i=i+1
    # break
  # break
  if(cur=={}):
    break
  # till=till+1


print("final table")
for i in pre:
  for j in i:
    print(j, end=" ")
  print(pre[i])
print()

